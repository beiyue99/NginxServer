
//a)多个进程写一个文件，可能会出现数据覆盖，混乱等情况
//b)ngx_log.fd = open((const char *)plogname,O_WRONLY|O_APPEND|O_CREAT,0644);  
//O_APPEND这个标记能够保证多个进程操作同一个文件时不会相互覆盖；
//c)内核wirte()写入时是原子操作；
//d)父进程fork()子进程是亲缘关系。是会共享文件表项，
//--------------关于write()写的安全问题，是否数据成功被写到磁盘；
//e)write()调用返回时，内核已经将应用程序缓冲区所提供的数据放到了内核缓冲区，
// 但是无法保证数据已经写出到其预定的目的地【磁盘 】；
//因为write()调用速度极快，可能没有时间完成该项目的工作【实际写磁盘】，
//（4.1）掉电导致write()的数据丢失破解法
//a)直接I/O：直接访问物理磁盘：
//O_DIRECT：绕过内核缓冲区。用posix_memalign
//b)open文件时用O_SYNC选项：
//同步选项【把数据直接同步到磁盘】,只针对write函数有效，使每次write()操作等待物理I/O操作的完成；
//具体说，就是将写入内核缓冲区的数据立即写入磁盘，将掉电等问题造成的损失减到最小；
//每次写磁盘数据，务必要大块大块写，一般都512-4k 4k的写；不要每次只写几个字节，否则会被抽死；************

//c)缓存同步：尽量保证缓存数据和写磁盘上的数据一致；
//sync(void)：将所有修改过的块缓冲区排入写队列；然后返回，并不等待实际写磁盘操作结束，数据是否写入磁盘并没有保证；
//fsync(int fd)：将fd对应的文件的块缓冲区立即写入磁盘，并等待实际写磁盘操作结束返回；
//fdatasync(int fd)：类似于fsync，但只影响文件的数据部分。而fsync不一样，fsync除数据外，还会同步更新文件属性；

//write(4k),1000次之后，一直到把这个write完整[假设整个文件4M]。
//fsync(fd) ,1次fsync [多次write,每次write建议都4k，然后调用一次fsync()，这才是用fsync()的正确用法]





//(1)拦截掉SIGHUP，那么终端窗口关闭，进程就不会跟着关闭
// 通知进程与终端的连接已经断开，对于大多数进程，SIGHUP 的默认动作是终止进程。
// 但是，对于一些守护进程或者经过特殊处理的进程，可能会忽略 SIGHUP 信号
//创建守护进程ngx_daemon（）；
//调用ngx_daemon（）的时机： worker()子进程创建之前；