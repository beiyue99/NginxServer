
	//int listen(int sockfd, int backlog); 
	//要理解好backlog这个参数，我们需要先谈一谈 “监听套接字 队列”的话题；
	//（1.1）监听套接字的队列
	//对于一个调用listen()进行监听的套接字，操作系统会给这个套接字 维护两个队列；
	//a)未完成连接队列 
		//当客户端 发送tcp连接三次握手的第一次【syn包】给服务器的时候，服务器就会在未完成队列中创建一个 跟这个syn包对应的一项，
	     //其实，我们可以把这项看成是一个半连接【因为连接还没建立起来呢】，这个半连接的状态会从LISTEN变成SYN_RCVD状态，
		 // 同时给客户端返回第二次握手包【syn,ack】

	//b)已完成连接队列
	     //当第三次握手完成了，这个连接就变成了ESTABLISHED状态，每个已经完成三次握手的客户端 都放在这个队列中作为一项；
	//backlog的含义：已完成队列和未完成队列里边条目之和 不能超过 backlog;
	//(1)客户端这个connect()什么时候返回，其实是收到三次握手的第二次握手包（也就是收到服务器发回来的syn/ack）之后就返回了；
	//(2)RTT是未完成队列中任意一项在未完成队列中留存的时间，这个时间取决于客户端和服务器；
	//对于客户端，这个RTT时间是第一次和第二次握手加起来的时间；
	//对于服务器，这个RTT时间实际上是第二次和第三次握手加起来的时间；
	//如果这三次握手包传递速度特别快的话，大概187毫秒能够建立起来这个连接；这个时间挺慢，所以感觉建立TCP连接的成本挺高；
    //(3)如果一个恶意客户，迟迟不发送三次握手的第三个包。那么这个连接就建立不起来，
	// 那么这个处于SYN_RCVD的这一项【服务器端的未完成队列中】，
	   //就会一直停留在服务器的未完成队列中，这个停留时间大概是几十秒，如果超过这个时间，这一项会被操作系统干掉；

	//（1.2）accept()函数
	//accept()函数，就使用来 从 已完成连接队列 中 的队首【队头】位置取出来一项【每一项都是一个已经完成三路握手的TCP连接】，
	// 返回给进程；
	//如果已完成连接队列是空的呢？那么咱们这个范例中accept()会一致卡在这里【休眠】等待，一直到已完成队列中有一项时才会被唤醒；
	 //所以，从编程角度，我们要尽快的用accept()把已完成队列中的数据【TCP连接】取走，大家必须有这个认识；

	//思考题：
	//(1)如果两个队列之和【已完成连接队列，和未完成连接队列】达到了listen()所指定的第二参数，也就是说队列满了；
	 //此时，再有一个客户发送syn请求，服务器怎么反应？
	 //实际上服务器会忽略这个syn，不给回应； 客户端这边，发现syn没回应，过一会会重发syn包；
	//(2)从连接被扔到已经完成队列中去，到accept()从已完成队列中把这个连接取出这个之间是有个时间差的，如果还没等accept()从
	   //已完成队列中把这个连接取走的时候，客户端如果发送来数据，这个数据就会被保存再已经连接的套接字的接收缓冲区里，
	   // 这个缓冲区有多大，最大就能接收多少数据量；




	//a)阻塞I/O
	//我调用一个函数，这个函数就卡在在这里，整个程序流程不往下走了【休眠sleep】，该函数卡在这里等待一个事情发生，
	// 只有这个事情发生了，这个函数才会往下走；
     //这种函数，就认为是阻塞函数；accept();
	//这种阻塞，并不好，效率很低；一般我们不会用阻塞方式来写服务器程序，效率低；
	//b)非阻塞I/O：不会卡住，充分利用时间片，执行更高；
	//非阻塞模式的两个鲜明特点：
	//(1)不断的调用accept(),recv()函数来检查有没有数据到来，如果没有，函数会返回一个特殊的错误标记来告诉你，也可能是EAGAIN；
	// 如果数据没到来，那么这里有机会执行其他函数，但是也得不停的再次调用accept(),recvfrom()来检查数据是否到来
	//(2)如果数据到来，那么就得卡在这里把数据从内核缓冲区复制到用户缓冲区，所以复制这个阶段是卡着完成的；

	//三：同步与异步I/O:这两个概念容易和 阻塞/非阻塞混淆；
	//a)异步I/O：调用一个异步I/O函数时，我门要给这个函数指定一个接收缓冲区，我还要给定一个回调函数；
	  //调用完一个异步I/O函数后，该函数会立即返回。 其余判断交给操作系统，操作系统会判断数据是否到来，如果数据到来了，
	  // 操作系统会把数据拷贝到你所提供的缓冲区里，然后调用你所指定的这个回调函数来通知你；
	//很容易区别非阻塞和异步I/O的差别：
	//（1）非阻塞I/O要不停的调用I/O函数来检查数据是否来，如果数据来了，就得卡在I/O函数这里把数据从内核缓冲区复制到用户缓冲区，
	// 然后这个函数才能返回；
	//（2）异步I/O根本不需要不停的调用I/O函数来检查数据是否到来，只需要调用一次，然后就可以干别的事情去了；
	    //内核判断数据到来，拷贝数据到你提供的缓冲区，调用你的回调函数来通知你，你并没有被卡在那里的情况；

	//b)同步I/O
	//select/poll。epoll。
	//1)调用select()判断有没有数据，有数据，走下来，没数据卡在那里；
	//2)select()返回之后，用recvfrom()去取数据；当然取数据的时候也会卡那么一下；
	//同步I/O感觉更麻烦，要调用两个函数才能把数据拿到手；
	//但是同步I/O和阻塞式I/O比，就是所谓的 I/O复用【用两个函数来收数据的优势】 能力；
	//（3.1）I / O复用
	//所谓I/O复用，就是我多个socket【多个TCP连接】可以弄成一捆【一堆】，我可以用select这种同步I/O函数在这等数据；
	//select()的能力是等多条TCP连接上的任意一条有数据来；，然后哪条TCP有数据来，我再用具体的比如recvfrom()去收。
	//所以，这种调用一个函数能够判断一堆TCP连接是否来数据的这种能力，叫I/O复用，英文I/O multiplexing【I/O多路复用】

	//很多资料把 阻塞I/O，非阻塞I/O，同步I/O归结为一类 ，因为他们多多少少的都有阻塞的行为发生；
	   //甚至有的资料直接就把 阻塞I/O，非阻塞I/O 都归结为同步I/O模型，这也是可以的】
	   //而把异步I/O单独归结为一类，因为异步I/O是真正的没有阻塞行为发生的；


//（3.4）epoll_wait()函数。红黑树用于快速确定哪些文件描述符发生了事件，而双向链表用于存储那些已经准备好数据的事件
	//epitem结构设计的高明之处：既能够作为红黑树中的节点，又能够作为双向链表中的节点；
	//（3.5）内核向双向链表增加节点
	//一般有四种情况，会使操作系统把节点插入到双向链表中；
	//a)客户端完成三路握手；服务器要accept();
	//b)当客户端关闭连接，服务器也要调用close()关闭；
	//c)客户端发送数据来的；服务器要调用read(),recv()函数来收数据；
	//d)当可以发送数据时；服务武器可以调用send(),write()；

}






	//（2.3）TCP粘包、缺包
	//tcp粘包问题
	//client发送abc,def,hij，三个数据包发出去；
	//a)客户端粘包现象
	//客户端因为有一个Nagle优化算法；
	//send("abc");  write()也可以
	//send("def");
	//send("hij");
	//因为Nagle算法存在的，这三个数据包被Nagle优化算法直接合并一个数据包发送出去；这就属于客户端粘包；
	//如果你关闭Nagle优化算法，那么你调用几次send()就发送出去几个包；那客户端的粘包问题就解决了；

	//b)服务器端粘包现象
	//服务器端两次 recv之间可能间隔100毫秒，那可能在这100毫秒内，客户端这三个包都到了，这三个包都被保存到了服务器端的
	   //针对该TCP连接收数据缓冲中【abcdefhij】；你再次recv一次，就可能拿到了全部的“abcdefhij”，这就叫服务器端的 粘包；

	//如何解决拆包问题：给收发的数据包定义一个统一的格式[规则]
	//包格式： 包头+包体 的格式；其中 包头 是固定长度【10字节】,在包头中，有一个成员变量会记录整个包【包头+包体】的长度；
	    //这样的话，先收包头，从包头中，我知道了整个包的长度，然后 用整个包的长度 - 10个字节 = 包体的长度。
	   //我再收 “包体的长度”这么多的字节； 收满了包体的长度字节数，我就认为，一个完整的数据包【包头+包体】收完；

	//收包总结：
	//（1）先收固定长度包头 10字节；
	//（2）收满后，根据包头中的内容，计算出包体的长度：整个长度-10
	//（3）我再收包体长度这么多的数据，收完了，一个包就完整了；
	//我们就认为受到了一个完整的数据包；从而解决了粘包的问题；




	        //惊群，有时候不一定完全惊动所有4个worker进程，可能只惊动其中2个等等，其中一个成功其余的accept4()都会返回-1；
        // 错误 (11: Resource temporarily unavailable【资源暂时不可用】) 
        // 大家可以写个简单的程序试下，在父进程中bind,listen，然后fork出子进程，
               //所有的子进程都accept这个监听句柄。这样，当新连接过来时，大家会发现，仅有一个子进程返回新建的连接，
               // 其他子进程继续休眠在accept调用上，没有被唤醒。
        //  【我的结论是：accept4可以认为基本解决惊群问题，但似乎并没有完全解决，有时候还会惊动其他的worker进程】
        //因为使用 accept4 函数创建非阻塞的套接字，即使没有连接请求准备好，也不会导致进程或线程阻塞，避免惊群




    //setvbuf(stdout,NULL,_IONBF,0); //这个函数. 直接将printf缓冲区禁止， printf就直接输出了。



    //对accept、send和recv而言，事件未发生时errno通常被设置成EAGAIN（意为“再来一次”）或者EWOULDBLOCK（意为“期待阻塞”）
	        //EAGAIN和EWOULDBLOCK应该是一样的值，表示没收到数据，
        // 一般来讲，在ET模式下会出现这个错误，因为ET模式下是不停的recv肯定有一个时刻收到这个errno，
        // 但LT模式下一般是来事件才收，所以不该出现这个返回值



	    //#define EINTR  4，EINTR错误的产生：当阻塞于某个系统调用的一个进程捕获某个信号，且相应信号处理函数返回时，
        // 该系统调用可能返回一个EINTR错误。
        //例如：在socket服务器端，设置了信号捕获机制，有子进程，
        // 当在父进程阻塞于系统调用时由父进程捕获到了一个有效信号时，内核会致使accept返回一个EINTR错误(被中断的系统调用)。

            (err == ECONNABORTED)  
             //对端的连接意外关闭、网络中断、或者连接超时等。由于软件引起的中止而失败


		//ngx_process_events_and_timers() 函数调用了 ngx_epoll_process_events(-1)，
        // 这意味着它会一直等待直到有事件发生。当工作进程在等待事件时，如果接收到信号（例如 SIGINT），
        // 会中断 ngx_epoll_process_events(-1) 的阻塞状态，使得函数返回。
        // 然后，工作进程会继续执行循环中的下一次迭代，从而再次调用 ngx_process_events_and_timers() 函数。



			//针对 当socket可写的时候【发送缓冲区没满】，会不停的触发socket可写事件 ,我们提出两种解决方案
	//b.1)第一种最普遍的解决方案:
	   //需要向socket写数据的时候把socket写事件通知加入到epoll中，等待可写事件，当可写事件来时操作系统会通知咱们；
	    //此时咱们可以调用wirte/send函数发送数据，当发送数据完毕后，把socket的写事件通知从红黑树中移除；
	   //缺点：即使发送很少的数据，也需要把事件通知加入到epoll，写完毕后，有需要把写事件通知从红黑树干掉
	//b.2)改进方案；
	//开始不把socket写事件通知加入到epoll,当我需要写数据的时候，直接调用write/send发送数据；
	  //如果返回了EAGIN【发送缓冲区满了，需要等待可写事件才能继续往缓冲区里写数据】，此时，我再把写事件通知加入到epoll，
	     //此时，就变成了在epoll驱动下写数据，全部数据发送完毕后，再把写事件通知从epoll中干掉；
	//优点：数据不多的时候，可以避免epoll的写事件的增加/删除，提高了程序的执行效率；




	new (address) Type;  //定位new
	address是指向已分配内存区域的指针，Type是要构造的对象类型。定位new会在指定的内存地址处构造一个对象



	epoll_wait(m_epollhandle,m_events,NGX_MAX_EVENTS,timer);
	//如果timer为-1则一直阻塞，如果timer为0则立即返回，即便没有任何事件
    //返回值：有错误发生返回-1，错误在errno中，比如你发个信号过来，就返回-1，错误信息是(4: Interrupted system call)
    //如果你等待的是一段时间，并且超时了，则返回0；
    //如果返回>0则表示成功捕获到这么多个事件【返回值里】



	//#define ECONNRESET 104 /* Connection reset by peer */
	//如果客户端没有正常关闭socket连接，却关闭了整个运行程序【真是够粗暴无理的，
    // 应该是直接给服务器发送rst包而不是4次挥手包完成连接断开】，那么会产生这个错误            
    //10054(WSAECONNRESET)--远程程序正在连接的时候关闭会产生这个错误--远程主机强迫关闭了一个现有的连接



	EPOLLERR | EPOLLHUP | EPOLLRDHUP
   //客户端关闭，如果服务器端挂着一个写通知事件，则这里个条件是可能成立的
