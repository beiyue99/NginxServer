



//int listen(int sockfd, int backlog); 
	//要理解好backlog这个参数，我们需要先谈一谈 “监听套接字 队列”的话题；
	//（1.1）监听套接字的队列
	//对于一个调用listen()进行监听的套接字，操作系统会给这个套接字 维护两个队列；
	//a)未完成连接队列 
		//当客户端 发送tcp连接三次握手的第一次【syn包】给服务器的时候，服务器就会在未完成队列中创建一个 跟这个syn包对应的一项，
	     //其实，我们可以把这项看成是一个半连接【因为连接还没建立起来呢】，这个半连接的状态会从LISTEN变成SYN_RCVD状态，
		 // 同时给客户端返回第二次握手包【syn,ack】

	//b)已完成连接队列
	     //当第三次握手完成了，这个连接就变成了ESTABLISHED状态，每个已经完成三次握手的客户端 都放在这个队列中作为一项；
	//backlog的含义：已完成队列和未完成队列里边条目之和 不能超过 backlog;
	//(1)客户端这个connect()什么时候返回，其实是收到三次握手的第二次握手包（也就是收到服务器发回来的syn/ack）之后就返回了；
    //(2)如果一个恶意客户，迟迟不发送三次握手的第三个包。那么这个连接就建立不起来，
	// 那么这个处于SYN_RCVD的这一项【服务器端的未完成队列中】，
	   //就会一直停留在服务器的未完成队列中，这个停留时间大概是几十秒，如果超过这个时间，这一项会被操作系统干掉；


		

	   	//思考题：
	//(1)如果两个队列之和【已完成连接队列，和未完成连接队列】达到了listen()所指定的第二参数，也就是说队列满了；
	 //此时，再有一个客户发送syn请求，服务器怎么反应？
	 //实际上服务器会忽略这个syn，不给回应； 客户端这边，发现syn没回应，过一会会重发syn包；

	//(2)从连接被扔到已经完成队列中去，到accept()从已完成队列中把这个连接取出这个之间是有个时间差的，如果还没等accept()从
	   //已完成队列中把这个连接取走的时候，客户端如果发送来数据，这个数据就会被保存再已经连接的套接字的接收缓冲区里，
	   // 这个缓冲区有多大，最大就能接收多少数据量；



	 //（3.4）epoll_wait()函数。红黑树用于快速确定哪些文件描述符发生了事件，而双向链表用于存储那些已经准备好数据的事件
	//epitem结构设计的高明之处：既能够作为红黑树中的节点，又能够作为双向链表中的节点；
	//（3.5）内核向双向链表增加节点
	//一般有四种情况，会使操作系统把节点插入到双向链表中；
	//a)客户端完成三路握手；服务器要accept();
	//b)当客户端关闭连接，服务器也要调用close()关闭；
	//c)客户端发送数据来的；服务器要调用read(),recv()函数来收数据；
	//d)当可以发送数据时；服务武器可以调用send(),write()；


	
    //int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
    //sockfd：套接字描述符，指定要设置选项的套接字。
    //level：选项所属的协议层或套接字层。SOL_SOCKET（通用套接字选项）和特定协议的级别，如 IPPROTO_TCP（TCP协议选项）。
    //optname：要设置的选项名称。这是一个整数常量，表示特定选项的标识符。
    //optval：指向包含选项值的缓冲区的指针。
    //optlen：选项值的长度。
//这段代码中的 setsockopt() 函数用于设置服务器套接字的选项。特别是，它使用了 SO_REUSEADDR 和 SO_REUSEPORT 选项。
/*  SO_REUSEADDR 和 SO_REUSEPORT 是套接字选项，用于控制套接字的行为。
它们通常用于在关闭套接字后立即重新启动服务器，而无需等待一段时间以使套接字地址可再次使用。
具体作用如下：
SO_REUSEADDR 选项允许套接字地址（IP地址和端口号）在释放后立即重用。这意味着即使之前的套接字连接尚未完全关闭，也可以立即绑定到相同的地址上。
SO_REUSEPORT 选项允许多个套接字绑定到相同的地址和端口上。这对于实现负载均衡和多进程 / 线程并发处理请求的服务器非常有用。*/




//小端转大端
int inet_pton(int af, const char* src, void* dst);
af:地址族(ip地址的家族包括ipv4和ipv6)协议
src : 传入参数, 对应要转换的点分十进制的ip地址 : 192.168.1.100
dst : 传出参数, 函数调用完成, 转换得到的大端整形IP被写入到这块内存中


//将大端的整形数,转换为小端的点分十进制的IP地址          
const char* inet_ntop(int af, const void* src, char* dst, socklen_t size);
参数:
size : 修饰dst参数的, 标记dst指向的内存中最多可以存储多少个字节

//第二个参数=0，表示信号量在线程之间共享，确实如此 ，如果非0，表示在进程之间共享
    //第三个参数=0，表示信号量的初始值，为0时，调用sem_wait()就会卡在那里卡着
    sem_init(&m_semEventSendQueue,0,0) 
