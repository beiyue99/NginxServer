

# 4. 相关操作函数

- ## sscanf函数

```c
// 函数原型
// 将参数str的字符串根据参数format字符串来转换并格式化数据，转换后的结果存于对应的参数内。
sscanf(const char* str, const char* format, ...)

具体功能如下：
（1）根据格式从字符串中提取数据。如从字符串中取出整数、浮点数和字符串等。
（2）取指定长度的字符串
（3）取到指定字符为止的字符串
（4）取仅包含指定字符集的字符串
（5）取到指定字符集为止的字符串

// 可以使用正则表达式进行字符串的拆分
// shell脚本的时候, 会将正则表达式, 其实就是字符串的匹配规则, 用特殊字符来描述一类字符串
/*
正则匹配规则:
  [1-9]: 匹配一个字符, 这个字符在 1-9 范围内就满足条件
  [2-7]: 匹配一个字符, 这个字符在 2-7 范围内就满足条件
  [a-z]: 匹配一个字符, 这个字符在 a-z 范围内就满足条件
  [A,b,c,D, e, f]: 匹配一个字符, 这个字符是集合中任意一个就满足条件
  [1-9, f-x]: 匹配一个字符, 这个字符是1-9, 或者f-x 集合中的任意一个就满足条件
  [^1]: ^代表否定, 匹配一个字符,这个字符只要不是1就满足条件
  [^2-8]: 匹配一个字符,这个字符只要不在 2-8 范围内就满足条件
  [^a-f]: 匹配一个字符,这个字符只要不在 a-f 范围内就满足条件
  [^ ]: 匹配一个字符,这个字符只要不是空格就满足条件
使用正则表达式如何取匹配字符串:
举例:
  正则表达式: [1-9][a-z], 可以匹配两个字符
  匹配方式: 从原始字符串开始位置遍历, 每遍历一个字符都需要和正则表达式进行匹配,
      满足条件继续向后匹配, 不满足条件, 匹配结束
      从新开始: 从正则表达式的第一个字符重新开始向后一次匹配
          当整个大字符串被匹配一遍, 就结束了
  abcdefg12345AABBCCDD893b
      - 匹配到一个子字符串: 3b
  1a2b3c4d5e6f7g12345AABBCCDD893b
   - 1a
   - 2b
   - 3c
   - 4d
   - 5e
   - 6f
   - 7g
   - 3b
*/
sscanf可以支持格式字符 % []：

(1) - : 表示范围，如： % [1 - 9]表示只读取1 - 9这几个数字 % [a - z]表示只读取a - z小写字母，类似地 % [A - Z]只读取大写字母
(2) ^ : 表示不取，如： % [^ 1]表示读取除'1'以外的所有字符 % [^ / ]表示除 / 以外的所有字符
(3), : 范围可以用","相连接 如 % [1 - 9, a - z]表示同时取1 - 9数字和a - z小写字母
(4)原则：从第一个在指定范围内的数字开始读取，到第一个不在范围内的数字结束 % s 可以看成 % [] 的一个特例 % [^ ](注意^ 后面有一个空格！)
```

```c
const char* s = "http://www.baidu.com:1234";
char protocol[32] = { 0 };
char host[128] = { 0 };
char port[8] = { 0 };
sscanf(s, "%[^:]://%[^:]:%[1-9]", protocol, host, port);

printf("protocol: %s\n", protocol);
printf("host: %s\n", host);
printf("port: %s\n", port);

///////////////
sscanf("123456 abcdedf", "%[^ ]", buf);
printf("%s\n", buf);
结果为：123456
///////////////
sscanf("123456abcdedfBCDEF", "%[1-9，a-z]", buf);
printf("%s\n", buf);
结果为：123456abcdedf
///////////////
sscanf("123456abcdedfBCDEF", "%[^A-Z]", buf);
printf("%s\n", buf);
结果为：123456abcdedf

```

